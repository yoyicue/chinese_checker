# 离线中国跳棋架构

**结论先说**：做一款**离线**的中国六角跳棋（Chinese Checkers）Android 应用，**不需要上游戏引擎**。用 **Kotlin + Jetpack Compose（含 Canvas）** 就能把规则、走法、高亮、动画、AI 全部优雅搞定，体积更小、冷启动更快、集成/测试也更顺。只有当你需要**跨平台**（iOS/桌面/网页）、大量特效或后续做更多棋类/街机类游戏时，再考虑 Godot / libGDX / Unity 等引擎。

**一句话结论**：这份文档等于一套**离线版中国跳棋的完整蓝图**——把模块划分、离线化裁剪、棋盘/走法/胜负判定、AI 分层、UI 流程、音效与资源、测试清单都串好了。即便我们选 **Kotlin + Jetpack Compose** 而不是 Flutter/Flame，文档里的**领域模型与工程化做法**仍可直接迁移或参考，能显著降低设计与实现的不确定性。

* * *

这份文档具体能帮我们什么？
-------------

### 1) 给出一套“离线优先”的**工程骨架**

文档把项目拆成入口/全局、数据层、**棋局核心（与 UI 解耦）**、界面层、音频/工具模块；并专门列出**离线化裁剪**（去掉在线依赖、购买/上报、网络状态等），这能直接指导我们在 Android 侧按“纯本地”的边界做架构与依赖选择。



*   **模块划分**清晰：入口/全局、data、game、ui、audio/util，便于我们把“规则/AI”做成**纯 Kotlin**模块再供 Compose UI 调用。
    
*   **离线化清单**明确：删除 Firebase/Crashlytics/内购，改用本地日志与震动/音频的轻量实现，避免隐形在线耦合。

### 2) 提供**初始化与状态管理**样板

虽然文档以 Flutter 为例（`main()` 初始化首选项/档案 → 注入 Settings/Themes/Music/Profile/OfflineConfig），但**初始化顺序**、**哪些状态需要全局管理**这些决策在 Android 也通用。我们可对应到 `Application`/`Hilt`/`ViewModel`/`DataStore`。



*   初始化顺序与“只注入离线必需状态”的建议，可直接套用到 Android：先本地存储→加载设置/档案→再启动 UI。
    

### 3) 直接可迁移的**领域模型与规则**

文档的“棋局核心”独立于 UI：采用 **立方坐标 Hex**、生成 121 孔棋盘、定义 `Move`（路径）、**单步+连续跳**的走法生成、胜负判定与距离评估，这些都可以 1:1 迁移到 Kotlin 的 `:domain` 模块。



*   **坐标/棋盘**：Hex（含旋转、距离）、模板化生成标准 121 节点棋盘。
    
*   **走法生成**：将 `allPossibleStepsFrom` 与 `allPossibleJumpsFrom` 合并，跳跃用 **DFS + 去重**产出**所有**连续跳路径（我们可在 UI 高亮层再做 BFS 得“最短可达”）。
    
*   **胜负/评估**：`checkWinner` 与“到目标营地的缺失距离”作为启发式评分，为 AI 与结算提供统一依据。
    

### 4) **AI 分层**与难度梯度可复用

从随机/贪婪到 Minimax（可选并发隔离）的分层明确了**难度渐进路线**：先落地 Greedy，再按性能增配 Minimax/启发排序/置换表。我们在 Kotlin 里用协程封装即可。



*   `WeakBot`（随机）、`GreedyBot`（距离启发）、`SmartBot(Minimax)` 的职责与接口边界清晰，便于替换实现。
    

### 5) **UI 流程**和交互要点现成可参照

“启动→离线配置→对局→设置/资料/教学”的导航流，以及对局页里**选择棋子、计算合法落点、播放动效/音效、切换玩家/AI**的控制器职责，都能直接映射到 Compose 的 `GameScreen` + `ViewModel`。



*   文档列出了对局页需要的**可视化元素**（高亮可落点、上一步走子、剩余时间等）与页面结构，有助于我们做 UI 需求清单与验收标准。
    
*   自带\*\*教学（HowToPlay）\*\*思路：以预录 `GameMove` 列表驱动“演示走法”，Compose 侧可用 `LaunchedEffect`/动画逐步回放。
    

### 6) **资源与演示资产**能显著加速出样

文档列出可复用的**音效/音乐、字体、头像、多套棋盘/棋子纹理、Shader**等目录结构；我们可把它们导入到 Android `assets/` 或 `res/raw`，快速获得可玩的视觉与听感。



### 7) **测试与调试**清单可直接变成我们的验收用例

包括走法合法性、胜负判定在不同玩家数下的正确性、AI 行为、设置项即时生效等场景，能减少“漏测规则”的风险。



* * *

Flutter/Flame → Kotlin/Compose 的**对照迁移表**
-----------------------------------------

| 文档里的做法 | 我们在 Android 侧的对应 |
| --- | --- |
| Provider + `main()` 初始化设置/档案 | `Hilt` 注入 + `Application` 初始化 + `ViewModel`/`StateFlow` 暴露状态|
|||

 |
| Hive/SharedPrefs 保存设置与档案 | `DataStore`（设置）+ `Room` 或本地 JSON/Proto（存档/统计）



 |
| `game/` 里 Hex/Board/Moves/Player/AI（UI 解耦） | `:domain` 纯 Kotlin；Compose 仅订阅状态并发事件



 |
| 跳跃用 DFS 枚举所有路径 | 规则层保留 DFS；UI 高亮层可用 BFS 求“最短落点路径” |
| `SmartBot(Minimax)`（可并发） | 协程 + `Dispatchers.Default`；增加可取消、置换表 |
| GoRouter 导航 | Navigation Compose（单 Activity、多目的地）



 |
| Flame 渲染/组件（棋盘、选中、高亮、计时等） | **Compose Canvas**（缓存网格位图，仅重绘棋子/高亮；`Animatable` 做连跳动画）



 |
| `audioplayers`/`Soundpool` + `HapticFeedback` | `SoundPool`/`MediaPlayer` + `Vibrator`/`performHapticFeedback`



 |
| 资源目录（音频、头像、纹理、Shader） | 导入 `assets/`/`res/raw`，按主题切换材质/配色



 |

* * *

用这份文档时要注意的两点
------------

1.  **引擎选择**：文档示例用 Flame 做渲染，但我们做**离线、纯 2D 棋类**且只面向 Android，Compose Canvas 足够；把 Flame 中“组件职责”迁移为 `GameViewModel` + 一组可组合的 `@Composable` 就好。
    
2.  **走法生成策略**：文档用 **DFS** 枚举“所有可能跳跃路径”；若 UI 只需提示“所有可达落点 + 一条可播放路径”，我们可在 UI 用 **BFS** 求最短动画路径，既快又直观。
    

* * *

基于文档的**落地路线（建议）**
-----------------

1.  **抽出领域层**：按文档的数据结构，先实现 `Hex/Board/Move/Rules` 与胜负/评估（Kotlin 版）。
    
2.  **走法与高亮**：规则层保留 DFS（产出全路径），UI 侧 BFS 求最短展示路径；加入循环去重。
    
3.  **AI**：先上 `Greedy`（用“缺失距离”评分），再加 Minimax（时间/深度可配）。
    
4.  **UI 流**：复刻“启动→离线配置→对局→设置/资料/教学”的页面串联与控制器职责。
    
5.  **资源导入**：用文档列的音效/纹理/头像先跑通视觉与回放/教学。
    
6.  **测试**：把文档中列举的规则/AI/设置场景，转成我们 CI 的单元/快照测试。
    

* * *

**总结**：这份文档不仅告诉我们“如何把跳棋做成**完全离线**的应用”，还把**核心棋局逻辑与工程边界**拆得很干净。把它当作“领域与流程规范”，再把 UI/平台层换成 Kotlin/Compose，我们就能在保证规则正确性与可维护性的同时，快速得到可玩的 Android 离线跳棋。



## Response:
Request for GPT-5 Pro

Reasoned for 5m 30s

下面是一份**面向 Kotlin + Jetpack Compose** 的「离线中国六角跳棋」完整产品设计（PRD + 技术方案合订版）。其中若干工程分层、离线化裁剪、棋局核心与 DFS 跳跃生成、AI 难度梯度、教学/资源组织等思路，参考了你们现有的离线版本设计资料并在 Android 侧做了等效改造与细化。



* * *

一、产品概述
======

1.1 目标与范围
---------

*   **目标**：在 Android 上提供**完全离线**、规则准确、体验流畅的中国六角跳棋（Chinese Checkers），支持 2/3/4/6 人、人与人同机对弈或人与 AI 对弈，提供教学、复盘、主题与音效/震动。
*   **平台**：Android 8.0（API 26）及以上。
*   **联网**：**不申请网络权限**；所有功能本地完成，数据仅存本地。
*   **商业化**：无内购与广告（可后续评估，但本设计不涉及在线依赖）。
    

1.2 目标用户与场景
-----------

*   **休闲玩家**：离线打发时间；希望开局快、规则简单明了、AI 可调。
*   **亲友/同学**：同机轮流（Hotseat）对弈。
*   **桌游爱好者**：在手机上进行规则一致的练习，期望支持悔棋/复盘/定式演示。

* * *

二、需求说明
======

2.1 核心功能（Must）
--------------

1.  **单机对战**：2/3/4/6 人；人-人、人-AI 混合；
2.  **AI 难度**：弱（随机/轻启发）、中（贪婪启发）、强（Minimax 限时）；
    
3.  **规则**：一步走、跨子连续多跳、胜负判定（目标营地占满）；允许配置若干民间差异（是否允许回退/是否必须最远等）；
4.  **局面管理**：新局、悔棋/重做、存档/读档（单存档自动保存 + 多存档可选）；
5.  **教学模式**：图文+演示回放（预置走法序列，逐步播放）；
    
6.  **UI/UX**：棋子选中与**可达落点高亮**、连跳动态播放、上一步提示、玩家/AI 指示、音效与震动；
7.  **配置与资料**：设置页（音量、震动、主题、难度、快捷规则开关）、本地玩家资料/头像、统计（胜/负/局时长）。

2.2 可选功能（Should）
----------------

*   **快节奏模式**（倒计时/回合限时）；
    
*   **主题与材质**：多套棋盘/棋子皮肤；资源结构可沿用并迁移到 Android `assets/`/`res`。
    
*   **教程引导**：首次启动时提供最小化引导（可跳过）。

2.3 非功能需求（NFR）
--------------

*   **性能**：中端机（A53 级别）棋盘交互 60fps、启动 < 800ms（冷启动不含首次资源解压）；
*   **包体**：≤ 25MB（基础主题 + 音效），可按需下载额外主题（若未来允许联网）；
*   **电量**：长局对弈 30 分钟，额外耗电 < 5%；
*   **可访问性**：TalkBack 标签、色盲友好配色（红/绿对比替换）、触控最小 48dp；
*   **隐私**：仅本地存储；可选导出；无联网采集；不集成 Crashlytics 等云依赖。
    

* * *

三、整体架构
======

采用**Clean + UDF（MVI）**分层，UI 与棋局/AI 完全解耦，利于单测复用与后续扩展。部分分层与**离线化裁剪**思路来源于既有方案（移除在线与内购相关模块，仅保留离线所需状态容器），在 Kotlin/Compose 侧进行映射与精简。



```
com.example.chinesecheckers
├─ :app        // 启动、DI、权限、导航
├─ :ui         // Compose 视图与手势、动画、主题
├─ :domain     // 棋盘/规则/胜负（纯 Kotlin，不依赖 Android）
├─ :ai         // 弱/贪婪/Minimax/MCTS（仅依赖 :domain）
├─ :data       // 存档/设置/资料（DataStore/JSON/Room 可选）
└─ :media      // 音效/震动封装、素材装载（离线）
```

**核心流转（UDF）**

```
UserIntent ──► ViewModel ──(reduce)──► GameState ──► UI(Compose)
                     │                       ▲
                     └─(SideEffect: AI)──────┘
```

*   `GameState`：不可变（当前玩家、121 孔位占用、选中子、可达集合、历史栈、赢家等）
*   `GameEvent`：点击格点、落子、悔棋、AI 完成、设置变更
*   `Reducer`：纯函数更新状态；AI 搜索/存盘为 SideEffect（协程）

> 参考文档强调“棋局核心独立于 UI、资源与平台”，我们等价保持：`:domain` 可单独跑单测与基准。
> 
> 

* * *

四、数据与持久化
========

*   **设置**：`DataStore`（音量、震动、主题、难度、快节奏、规则开关）；对应 Flutter 侧的设置 Provider 思路。
    
*   **资料**：本地 `profiles.json` 或 Room 表（昵称、头像、胜负统计、最近游玩时间）；
    
*   **存档**：`saves/` 下以 JSON/Proto 持久化（当前局面、历史栈、规则与玩家配置）。
*   **无网依赖**：不接云端、无在线日志；崩溃日志可本地落盘（用户同意后导出反馈）。
    

* * *

五、棋盘与规则设计（:domain）
==================

5.1 棋盘与坐标
---------

*   **盘面**：标准 121 孔（中心六边形 + 六个三角臂）。
*   **坐标**：两种方案均支持
    1.  **预索引 0..120**（推荐）：便于预计算邻居与跳跃边；
    2.  **Hex 轴坐标（q,r）**：灵活生成盘面/旋转/距离计算，便于泛化。文档范式采用 Hex 并提供旋转/距离等工具，思路可直接迁移。
        

**数据结构示例**

```kotlin
// 预计算于初始化：neighbors[i], jumpEdges[i] 等
data class JumpEdge(val mid: Int, val landing: Int)

data class Board(
    val cells: IntArray, // -1 空；0..5 玩家ID
    val currentPlayer: Int
)
```

5.2 合法走法与多跳
-----------

*   **一步**：移动至相邻空孔。
*   **多跳**：隔一个被占孔跳至对面空孔，可**连续跳**，期间不可落在非空孔。
*   **生成策略**：
    *   单步：常规枚举相邻；
    *   跳跃：以**DFS**枚举所有连续跳路径（领域层完整生成，以便 AI 与“演示/复盘”）。该策略与现有文档一致。
        
    *   UI 高亮：从起点对“跳跃边”做 **BFS**，得到“所有可达落点 + 一条最短路径”，用于直观展示与动画。

**多跳可达（Kotlin 伪码）**

```kotlin
fun reachableJumps(
    start: Int,
    occupied: BooleanArray,
    jumpEdges: Array<IntArray> // landing list; mid 用另一个表或打包
): Map<Int, List<Int>> {
    val visited = BooleanArray(occupied.size)
    val prev = IntArray(occupied.size) { -1 }
    val q: ArrayDeque<Int> = ArrayDeque()
    visited[start] = true
    q += start
    while (q.isNotEmpty()) {
        val u = q.removeFirst()
        for (v in jumpEdges[u]) {
            val mid = /* compute or lookup mid between u and v */
            if (occupied[mid] && !occupied[v] && !visited[v]) {
                visited[v] = true
                prev[v] = u
                q += v
            }
        }
    }
    return buildMap {
        for (i in visited.indices) if (visited[i] && i != start) {
            put(i, buildList {
                var x = i
                while (x != start && x != -1) { add(0, x); x = prev[x] }
            })
        }
    }
}
```

5.3 胜负判定与规则开关
-------------

*   **胜负**：某玩家**完全占满**其对面三角营地即胜；
*   **评估**：棋子到目标营地的距离/缺失度累计（用于 AI 与残局判断）；该思路与参考实现一致。
    
*   **可配置差异**：是否允许回退、是否必须选择最长/最远跳、是否允许“留在原营地”等，均作为设置项。

* * *

六、AI 设计（:ai）
============

6.1 难度梯度与接口
-----------

*   **WeakBot**：随机合法走法；
*   **GreedyBot**：以“缺失距离和”/“水平进步”作为启发；
*   **SmartBot**（两人优先）：**Minimax + α-β**，深度/时限可配置；
*   **多人局**：`Paranoid` 或 `Max-n` 简化策略；或 **MCTS**（时间片驱动）。  
    上述层次及评估指标与参考资料一致，但实现以 Kotlin/协程为主，支持取消与限时。
    

**接口示例**

```kotlin
interface Bot {
    suspend fun nextMove(board: Board, playerId: Int, deadlineMs: Long): Move
}
```

6.2 实现要点
--------

*   **时间管理**：`withTimeoutOrNull(deadline)` + 迭代加深；
*   **置换表**：Zobrist Hash（`Long`）→ `MutableMap<Long, Entry>`；
*   **启发排序**：多跳 > 距离改进大 > 靠近目标营地；
*   **取消**：在节点展开处检查 `coroutineContext.isActive`，UI 操作（悔棋/落子）立即中断计算。

* * *

七、UI/UX 设计（:ui）
===============

7.1 主要页面与导航
-----------

*   **Start**：快速开始、离线对战、教学、设置、资料；
*   **Offline Setup**：玩家数、人机混合、AI 难度、规则开关、快节奏；
    
*   **Game**：棋盘、回合指示、可达高亮、上一步、计时/剩余时间、胜负弹窗；
*   **Settings**：音量/震动/主题/快节奏/规则；
*   **Profiles**：头像/昵称/统计；
*   **HowToPlay**：**脚本化演示**若干典型走法，逐步播放（与现有“示例走法”思路一致）。
    

> 导航与状态初始化顺序（先本地设置与资料，再启动 UI）与参考文档一致，只是将 Flutter Provider / Router 对应为 `ViewModel/StateFlow + Navigation Compose`。
> 
> 

7.2 棋盘呈现（Compose Canvas）
------------------------

*   **绘制**：使用 `Canvas` 预渲染**静态网格**到 `ImageBitmap`，只动态绘制棋子/高亮/提示；
*   **交互**：点击/拖拽 → 命中检测（放大触控半径）→ 高亮邻步与跳跃落点；
*   **动画**：按路径逐段补间（`Animatable<Offset>`）；多跳每段结束触发下一段；
*   **可访问性**：TalkBack 描述（“红方棋子移动至 (x,y)，连续三跳”）、高对比模式；
*   **音效/震动**：落子/非法/胜利分别触发不同 SFX 与 haptics；资源目录映射到 Android。
    

**Compose 片段示例**

```kotlin
@Composable
fun BoardCanvas(state: GameState, onTap: (Int) -> Unit) {
    Canvas(Modifier
        .fillMaxSize()
        .pointerInput(state.hashCode()) {
            detectTapGestures { offset ->
                onTap(hitTestCell(offset)) // 命中转 id
            }
        }
    ) {
        // drawCachedGrid()
        drawPieces(state.cells)
        drawHighlights(state.reachable)
        drawLastMove(state.lastMove)
    }
}
```

* * *

八、媒体与资源（:media）
===============

*   **音效**：按钮/落子/胜利/错误等；
*   **音乐**：可选背景乐，设置为 0 则停止并释放；
*   **震动**：轻度/重度反馈映射到系统 Haptics；
*   **主题材质**：棋盘/棋子多主题（beach、marbles、planets… 等可参考并迁移）；在 Android 以 `assets/`/`res/drawable` 组织。
    

> 参考资料已有清晰的**资源分层与清单**（音频/字体/头像/棋盘材质/Shader 等），迁移到 Android 可直接复用大部分素材及目录结构思想。
> 
> 

* * *

九、配置与初始化
========

*   **Application.onCreate**：加载 DataStore/本地档案 → 初始化主题/音频 → 注入 DI（Hilt/Koin）；
*   **首帧策略**：延后加载非关键资源（背景乐、非当前主题包）；
*   **仅离线状态**：不初始化任何在线 SDK；将崩溃/统计替换为本地可选记录。
    

* * *

十、技术选型与依赖
=========

*   **语言**：Kotlin（1.9+）
*   **UI**：Jetpack Compose BOM（Material3、Navigation、Lifecycle、Animation）
*   **状态**：ViewModel + StateFlow + Immutable data models
*   **并发**：Coroutines（`Dispatchers.Default` for AI）
*   **DI**：Hilt 或 Koin（小体量亦可手动注入）
*   **存储**：DataStore（设置）、kotlinx-serialization/Proto（存档）、Room（可选）
*   **日志**：Timber（或自研文件日志）
*   **音频**：`SoundPool`（短 SFX）、`MediaPlayer`（背景乐，可选）

* * *

十一、测试与质量
========

11.1 单元与属性测试
------------

*   规则：一步/多跳/边界/循环去重；
*   胜负：不同玩家数/目标营地映射正确；
*   AI：对典型局面输出优于弱/随机基线；
*   属性：悔棋-重做可往返；旋转/镜像等价局面评估一致。

11.2 UI/端到端
-----------

*   Compose UI 测试：高亮与动画触发、设置即时生效、对局结束弹窗；
*   无障碍：TalkBack 文案、触控面积、对比度；
*   性能：渲染 jank 监控、AI 限时正确中断。

> 参考资料中已有**走法/胜负/AI 行为**等测试点的清单，我们在此基础上补充端到端与可访问性用例。
> 
> 

* * *

十二、性能与稳定性策略
===========

*   **渲染**：缓存网格、减少 `Canvas` 重绘区域；
*   **对象**：复用 `IntArray/BooleanArray`；避免装箱；
*   **AI**：限时 + 迭代加深 + 启发排序 + 置换表；
*   **内存**：移动动画逐段复用 `Animatable`；
*   **稳定性**：捕获未处理异常，提示“保存并恢复”；日志仅本地。
    

* * *

十三、隐私与合规
========

*   不申请 `INTERNET`；
*   所有数据本地存储；
*   提供“导出/清除数据”入口；
*   不写入跨应用可读路径；
*   可选本地崩溃日志并可导出（默认关闭）。
    

* * *

十四、里程碑与范围控制
===========

| 里程碑 | 目标 | 关键内容 |
| --- | --- | --- |
| **MVP（4–6 周）** | 可玩 | 2 人对战、弱/贪婪 AI、悔棋/重做、单存档自动保存、主题 1 套、音效、教学最小版 |
| **Beta（+3–4 周）** | 完整性 | 2/3/4/6 人、AI 强度限时、规则开关、快节奏、资料与统计、主题扩展、无障碍合规 |
| **GA（+2 周）** | 打磨 | 性能优化、动画/材质细化、QA 全覆盖、商店素材与上架文档 |

> 教学/资源/配置/离线裁剪均已有成熟思路，迁移成本可控。
> 
> 

* * *

十五、关键类与示例代码
===========

15.1 状态与事件
----------

```kotlin
data class GameState(
    val cells: IntArray,         // 121
    val currentPlayer: Int,
    val selected: Int? = null,
    val reachable: Map<Int, List<Int>> = emptyMap(),
    val lastMove: Move? = null,
    val winner: Int? = null,
    val history: List<Move> = emptyList()
)

sealed interface GameEvent {
    data class Tap(val cell: Int): GameEvent
    data class AIMoveReady(val move: Move): GameEvent
    data object Undo: GameEvent
    data object Redo: GameEvent
    data object NewGame: GameEvent
}
```

15.2 走法与评估
----------

```kotlin
data class Move(val path: IntArray) // 含连续跳路径

fun evaluate(board: Board, playerId: Int): Int {
    // 所有己子到目标营地的距离和（越小越好）
    return board.allPieces(playerId).sumOf { distToHome(it, playerId) }
}
```

15.3 ViewModel（UDF）
-------------------

```kotlin
class GameViewModel(
    private val rules: Rules,
    private val repo: SaveRepository,
    private val bot: Bot?
) : ViewModel() {
    private val _state = MutableStateFlow(GameState(/*...*/))
    val state: StateFlow<GameState> = _state

    fun onEvent(e: GameEvent) = when(e) {
        is GameEvent.Tap -> handleTap(e.cell)
        is GameEvent.AIMoveReady -> applyMove(e.move)
        GameEvent.Undo -> undo()
        GameEvent.Redo -> redo()
        GameEvent.NewGame -> newGame()
    }

    private fun handleTap(cell: Int) { /* 选子→计算 reachable（BFS 跳跃边）→落子 */ }
}
```

* * *

十六、验收标准（节选）
===========

*   **规则**：任意合法局面，连续跳枚举与 UI 可达一致；DFS 生成的路径用于教学/AI，BFS 高亮用于交互；
    
*   **AI**：在给定测试局面中，强 AI 的评估分数优于贪婪，贪婪优于随机；
*   **性能**：中端机 60fps 渲染、强 AI 单步 ≤ 300ms（限时）且可取消；
*   **离线**：移除网络权限，所有功能在飞行模式可用；
*   **可访问性**：TalkBack 覆盖关键控件，触控命中 ≥ 48dp。

* * *

十七、风险与应对
========

*   **AI 深度导致卡顿** → 限时 + 迭代加深 + 取消；
*   **多跳组合爆炸** → 领域层保留 DFS，但 UI 仅 BFS 展示；
*   **盘面重绘开销** → 缓存网格、只绘变更层；
*   **规则差异认知** → 显式规则开关 + 教学说明。

* * *

结语
--

本方案以**Kotlin/Compose 原生实现**为核心，严格离线、UI 与棋局彻底解耦、可测试与可扩展性强；关键工程分层、离线裁剪、棋局核心与 AI 难度梯度设计均与既有资料思路一致并完成 Android 化落地规划。后续只需按里程碑推进实现与验证即可落地可用版本。
